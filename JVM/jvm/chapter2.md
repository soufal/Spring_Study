### 第2章 Java内存区域与内存溢出异常

#### 2.2 运行时数据区域

Java虚拟机在执行Java程序的过程中，会把它管理的内存划分为若干个不同的数据区域。

* 运行时的数据区域：
  * 方法区（Method Area）（*由所有线程共享的数据区*）
  * 堆（Heap）（*由所有线程共享的数据区*）
  * 虚拟机栈（VM Stack）（*线程隔离的数据区*）
    * 虚拟机栈描述的是Java方法执行的**线程内存模型**：
      * 每个方法被执行时，Java虚拟机会同步创建一个**栈帧（Stack Frame）** 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
      每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
      * 这里的“栈内存”通常指的是虚拟机栈中的**局部变量表** 部分。
        * 局部变量表存放了编译器可知的各种数据类型、对象引用（reference类型）和`returnAddress`类型（指向了一条字节码指令的地址）；
        * 这些数据类型的存储空间以**局部变量槽（Slot）** 来表示，除了64位长度的`long`和`double`类型占用两个`Slot`外，其余都只占用一个`Slot`；
        * 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变大小（变量槽的数量）；
    * 两种异常情况：
      * `StackOverflowError`异常：如果线程请求的栈深度大于虚拟机所允许的深度；
      * `OutOfMemoryError`异常：线程申请栈空间失败（如果Java虚拟机栈容量可以动态拓展（如Classic虚拟机），当栈拓展时无法申请到足够的内存时）；
  * 本地方法栈（Native Method Stack）（*线程隔离的数据区*）
  * 程序计数器（Program Counter Register）（*线程隔离的数据区*）
    * 是一块较小的内存空间，看做是当前线程所执行的字节码的行号指示器；
    * 一个线程拥有一个独立的程序计数器，互不影响，独立存储；
    * 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器；
    * 该内存区域是唯一一个**没有规定任何`OutOfMemoryError`** 情况的区域。

> **线程私有**内存：线程隔离的数据区。